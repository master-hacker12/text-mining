<?xml version="1.0"?>
<doc>
    <assembly>
        <name>EP.Core</name>
    </assembly>
    <members>
        <member name="T:EP.Semantix.BracketHelper">
            <summary>
            Поддержка анализа скобок и кавычек
            </summary>
        </member>
        <member name="M:EP.Semantix.BracketHelper.CanBeStartOfSequence(EP.Semantix.Token,System.Boolean,System.Boolean)">
            <summary>
            Проверка, что с этого терма может начинаться последовательность
            </summary>
            <param name="t">проверяемый токен</param>
            <param name="quotesOnly">должны быть именно кавычка, а не скобка</param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.BracketHelper.CanBeEndOfSequence(EP.Semantix.Token,System.Boolean,EP.Semantix.Token,System.Boolean)">
            <summary>
            Проверка, что на этом терме может заканчиваться последовательность
            </summary>
            <param name="t">закрывающая кавычка</param>
            <param name="quotesOnly">должны быть именно кавычка, а не скобка</param>
            <param name="openT">это ссылка на токен, который мог быть открывающим</param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.BracketHelper.IsBracket(System.Char,System.Boolean)">
            <summary>
            Проверка символа, что он может быть скобкой или кавычкой
            </summary>
            <param name="ch"></param>
            <param name="quotsOnly"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.BracketHelper.IsBracket(EP.Semantix.Token,System.Boolean)">
            <summary>
            Проверка токена, что он является скобкой или кавычкой
            </summary>
            <param name="t"></param>
            <param name="quotsOnly"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.BracketHelper.TryParse(EP.Semantix.Token,EP.Semantix.BracketParseAttr,System.Int32)">
            <summary>
            Попробовать восстановить последовательность, обрамляемой кавычками
            </summary>
            <param name="t"></param>
            <param name="typ">параметры выделения</param>
            <param name="maxTokens">максимально токенов (вдруг забыли закрывающую ккавычку)</param>
            <returns></returns>
        </member>
        <member name="T:EP.Semantix.BracketParseAttr">
            <summary>
            Параметры выделения последовательности
            </summary>
        </member>
        <member name="F:EP.Semantix.BracketParseAttr.CanContainsVerbs">
            <summary>
            По умолчанию, посл-ть не должна содержать чистых глаголов (если есть, то null).
            Почему так? Да потому, что это используется в основном для имён именованных
            сущностей, а там не может быть глаголов.
            Если же этот ключ указан, то глаголы не проверяются.
            </summary>
        </member>
        <member name="F:EP.Semantix.BracketParseAttr.NearCloseBracket">
            <summary>
            Брать первую же подходящую закрывающую кавычку
            </summary>
        </member>
        <member name="F:EP.Semantix.BracketParseAttr.CanBeManyLines">
            <summary>
            Внутри могут быть переходы на новую строку (многострочный)
            </summary>
        </member>
        <member name="T:EP.SourceOfAnalysis">
            <summary>
            Анализируемый текст
            </summary>
        </member>
        <member name="F:EP.SourceOfAnalysis.ClearDust">
            <summary>
            Игнорировать сбойные участки (это участки с неправильной кодировкой,
            мусором и т.п.)
            </summary>
        </member>
        <member name="M:EP.SourceOfAnalysis.#ctor(System.String)">
            <summary>
            Создать контейнер на основе плоского текста.
            При создании будут автоматически сделаны транслитеральные замены, если они будут найдены.
            </summary>
            <param name="txt">Текст</param>
        </member>
        <member name="M:EP.SourceOfAnalysis.DoCrLfCorrection(System.String)">
            <summary>
            Это анализ случаев принудительно отформатированного текста
            </summary>
            <param name="txt"></param>
        </member>
        <member name="F:EP.SourceOfAnalysis.CrlfCorrectedCount">
            <summary>
            Факт исправления переходов на новую строку
            </summary>
        </member>
        <member name="F:EP.SourceOfAnalysis.DoWordCorrectionByMorph">
            <summary>
            Пытаться ли делать коррекцию слов, не попавших в словарь.
            </summary>
        </member>
        <member name="F:EP.SourceOfAnalysis.DoWordsMergingByMorph">
            Объединять соседние слова, не попавшие в словарь, если при объединении получается слово из словаря
            (очень полезно для текстов из PDF)
        </member>
        <member name="F:EP.SourceOfAnalysis.CorrectionDict">
            <summary>
            Словарь корректировки типовых ошибок.
            Ключ - ошибочное написание, Значение - правильное.
            Ключи и значения должны быть в верхнем регистре и без Ё.
            </summary>
        </member>
        <member name="M:EP.SourceOfAnalysis.DoTransliteralCorrection(System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>
            Произвести транслитеральную коррекцию
            </summary>
            <param name="txt">корректируемый текст</param>
            <param name="info">информация о замене (может быть null)</param>
            <returns>количество замен</returns>
        </member>
        <member name="M:EP.SourceOfAnalysis.Substring(System.Int32,System.Int32)">
            <summary>
            Извлечь фрагмент из исходного текста
            </summary>
            <param name="position"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:EP.SourceOfAnalysis.CalcWhitespaceDistanceBetweenPositions(System.Int32,System.Int32)">
            <summary>
            Вычислить расстояние в символах между соседними элементами
            </summary>
            <param name="indFrom"></param>
            <param name="indTo"></param>
            <returns></returns>
        </member>
        <member name="P:EP.SourceOfAnalysis.Text">
            <summary>
            Исходный плоский текст
            </summary>
        </member>
        <member name="P:EP.SourceOfAnalysis.Tag">
            <summary>
            Используется произвольным образом
            </summary>
        </member>
        <member name="T:EP.Semantix.NumberHelper">
            <summary>
            Работа с числовыми значениями
            </summary>
        </member>
        <member name="M:EP.Semantix.NumberHelper._tryParse(EP.Semantix.Token)">
            <summary>
            Попробовать создать числительное
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.NumberHelper.TryParseRoman(EP.Semantix.Token)">
            <summary>
            Попробовать выделить римскую цифру
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.NumberHelper.TryParseRomanBack(EP.Semantix.Token)">
            <summary>
            Выделить римскую цифру с token в обратном порядке
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.NumberHelper.TryParseAge(EP.Semantix.Token)">
            <summary>
            Это выделение числительных типа 16-летие, 50-летний
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.NumberHelper.TryParseAnniversary(EP.Semantix.Token)">
            <summary>
            Выделение годовщин и летий (XX-летие) ...
            </summary>
        </member>
        <member name="M:EP.Semantix.NumberHelper.GetNumberAdjective(System.Int32,EP.Text.MorphGender,EP.Text.MorphNumber)">
            <summary>
            Преобразовать число в числительное, записанное буквами, в соотв. роде и числе.
            Например, 5 жен.ед. - ПЯТАЯ,  26 мн. - ДВАДЦАТЬ ШЕСТЫЕ
            </summary>
            <param name="value">значение</param>
            <param name="gender">род</param>
            <param name="num">число</param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.NumberHelper.GetNumberRoman(System.Int32)">
            <summary>
            Получить для числа римскую запись
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.NumberHelper.TryParseFloatNumber(EP.Semantix.Token)">
            <summary>
            Выделить дробное число
            </summary>
            <param name="t">начальный токен</param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.NumberHelper.TryParseNumberWithPostfix(EP.Semantix.Token)">
            <summary>
            Выделение стандартных мер, типа: 10 кв.м.
            </summary>
            <param name="t">начальный токен</param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.NumberHelper.TryAttachPostfixOnly(EP.Semantix.Token)">
            <summary>
            Это попробовать только тип (постфикс) без самого числа.
            Например, куб.м.
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.NumberHelper.IsMoneyChar(EP.Semantix.Token)">
            <summary>
            Если этообозначение денежной единицы (н-р, $), то возвращает код валюты
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:EP.TextAnnotation">
            <summary>
            Аннотация слитного фрагмента текста
            </summary>
        </member>
        <member name="F:EP.TextAnnotation.Sofa">
            <summary>
            Ссылка на текст
            </summary>
        </member>
        <member name="F:EP.TextAnnotation.BeginChar">
            <summary>
            Начальная позиция фрагмента
            </summary>
        </member>
        <member name="F:EP.TextAnnotation.EndChar">
            <summary>
            Конечная позиция фрагмента
            </summary>
        </member>
        <member name="F:EP.TextAnnotation.EssentialForOccurence">
            <summary>
            Указание на то, что текущая сущность была выделена на основе правил
            на данном фрагменте текста.
            </summary>
        </member>
        <member name="M:EP.TextAnnotation.GetText">
            <summary>
            Извлечь фрагмент исходного текста, соответствующий аннотации
            </summary>
            <returns></returns>
        </member>
        <member name="P:EP.TextAnnotation.OccurenceOf">
            <summary>
            Ссылка на сущность
            </summary>
        </member>
        <member name="T:EP.Processor">
            <summary>
            Семантический процессор
            </summary>
        </member>
        <member name="M:EP.Processor.#ctor">
            <summary>
            Создание экземпляра процессора, в Workflow включаются все общие анализаторы
            (то есть те, которые не помечены как IsSpecific)
            </summary>
        </member>
        <member name="M:EP.Processor.#ctor(System.String)">
            <summary>
            Вариант создания, при котором в Workflow включаются все общие анализаторы и
            плюс указанный специфический.
            </summary>
            <param name="specificAnalyzerName">можно несколько, разделённые запятой</param>
        </member>
        <member name="M:EP.Processor.#ctor(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Вариант создания для фиксированного списка анализаторов
            </summary>
            <param name="analyzers">список типов картриджей</param>
        </member>
        <member name="M:EP.Processor.AddAnalyzer(EP.Analyzer)">
            <summary>
            Добавить анализатор, если его ещё нет
            </summary>
            <param name="a"></param>
        </member>
        <member name="M:EP.Processor.DelAnalyzer(EP.Analyzer)">
            <summary>
            Удалить анализатор
            </summary>
            <param name="a"></param>
        </member>
        <member name="M:EP.Processor.FindAnalyzer(System.String)">
            <summary>
            Найти анализатор по его имени
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Processor.Process(EP.SourceOfAnalysis,EP.ExtOntology,EP.Text.MorphLang)">
            <summary>
            Обработать текст
            </summary>
            <param name="text">входной контейнер текста</param>
            <param name="extOntology">внешняя онтология (null - не используется)</param>
            <param name="lang">язык (если не задан, то будет определён автоматически)</param>
            <returns>аналитический контейнер с результатом</returns>
        </member>
        <member name="M:EP.Processor.Process(EP.AnalysisResult)">
            <summary>
            Доделать результат, который был сделан другим процессором
            </summary>
            <param name="ar"></param>
        </member>
        <member name="M:EP.Processor.Break">
            <summary>
            Прервать процесс анализа
            </summary>
        </member>
        <member name="F:EP.Processor.TimeoutSeconds">
            <summary>
            Максимальное время обработки, прервёт при превышении.
            По умолчанию (0) - неограничено.
            </summary>
        </member>
        <member name="M:EP.Processor.DeserializeReferent(System.String,System.String,System.Boolean)">
            <summary>
            Десериализация сущности
            </summary>
            <param name="data">результат сериализации, см. Referent.Serialize()</param>
            <param name="ontologyElement">если не null, то элемент будет добавляться к внутренней онтологии,
            и при привязке к нему у сущности будет устанавливаться соответствующее свойство (Referent.OntologyElement)</param>
            <returns></returns>
        </member>
        <member name="M:EP.Processor.DeserializeReferent(System.Xml.XmlNode,System.String,System.Boolean)">
            <summary>
            Десериализация сущности из узла XML
            </summary>
            <param name="xml"></param>
            <param name="identity"></param>
            <returns></returns>
        </member>
        <member name="F:EP.Processor.Tag">
            <summary>
            Используется произвольным образом
            </summary>
        </member>
        <member name="F:EP.Processor.MiscData">
            <summary>
            Используется произвольным образом
            </summary>
        </member>
        <member name="P:EP.Processor.Analyzers">
            <summary>
            Последовательность обработки данных (анализаторы)
            </summary>
        </member>
        <member name="E:EP.Processor.Progress">
            <summary>
            Событие обработки строки состояния процесса.
            Там-же в событии ProgressChangedEventArg в UserState выводятся информационные сообщения.
            Внимание, если ProgressPercentage &lt; 0, то учитывать только информационное сообщение в UserState.
            </summary>
        </member>
        <member name="T:EP.ProxyReferent">
            <summary>
            Это заглушка референта при десериализации
            </summary>
        </member>
        <member name="T:EP.Semantix.Internal.NounPhraseItem">
            <summary>
            Элемент именной группы
            </summary>
        </member>
        <member name="T:EP.Semantix.MetaToken">
            <summary>
            Токен - надстройка над диапазоном других токенов
            </summary>
        </member>
        <member name="T:EP.Semantix.Token">
            <summary>
            Базовый элемент
            </summary>
        </member>
        <member name="F:EP.Semantix.Token.Kit">
            <summary>
            Аналитический контейнер
            </summary>
        </member>
        <member name="F:EP.Semantix.Token.BeginChar">
            <summary>
            Начальная позиция
            </summary>
        </member>
        <member name="F:EP.Semantix.Token.EndChar">
            <summary>
            Конечная позиция
            </summary>
        </member>
        <member name="F:EP.Semantix.Token.Tag">
            <summary>
            Используется произвольным образом
            </summary>
        </member>
        <member name="F:EP.Semantix.Token.Chars">
            <summary>
            Информация о символах
            </summary>
        </member>
        <member name="M:EP.Semantix.Token.GetReferent">
            <summary>
            Ссылка на сущность (для ReferentToken)
            </summary>
        </member>
        <member name="M:EP.Semantix.Token.GetReferents">
            <summary>
            Получить список ссылок на все сущности, скрывающиеся под элементом
            (дело в том, что одни сущности могут поглощать дркгие, например, адрес поглотит город)
            </summary>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.Token.GetNormalCaseText(System.Nullable{EP.Text.MorphClass},System.Boolean,EP.Text.MorphGender,System.Boolean)">
            <summary>
            Получить связанный с токеном текст в именительном падеже
            </summary>
            <param name="mc"></param>
            <param name="singleNumber">переводить ли в единственное число</param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.Token.GetSourceText">
            <summary>
            Получить чистый фрагмент исходного текста
            </summary>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.Token.GetMorphClassInDictionary">
            <summary>
            Проверка, что это текстовый токен и есть в словаре соотв. тип
            </summary>
            <param name="cla"></param>
            <returns></returns>
        </member>
        <member name="P:EP.Semantix.Token.LengthChar">
            <summary>
            Длина в исходных символах
            </summary>
        </member>
        <member name="P:EP.Semantix.Token.Previous">
            <summary>
            Предыдущий токен
            </summary>
        </member>
        <member name="P:EP.Semantix.Token.Next">
            <summary>
            Следующий токен
            </summary>
        </member>
        <member name="P:EP.Semantix.Token.Morph">
            <summary>
            Морфологическая информация
            </summary>
        </member>
        <member name="P:EP.Semantix.Token.IsWhitespaceBefore">
            <summary>
            Наличие пробельных символов перед
            </summary>
        </member>
        <member name="P:EP.Semantix.Token.IsWhitespaceAfter">
            <summary>
            Наличие пробельных символов после
            </summary>
        </member>
        <member name="P:EP.Semantix.Token.IsNewlineBefore">
            <summary>
            Элемент начинается с новой строки.
            Для 1-го элемента всегда true.
            </summary>
        </member>
        <member name="P:EP.Semantix.Token.IsNewlineAfter">
            <summary>
            Элемент заканчивает строку.
            Для последнего элемента всегда true.
            </summary>
        </member>
        <member name="P:EP.Semantix.Token.InnerBool">
            <summary>
            Это используется внутренним образом
            </summary>
        </member>
        <member name="P:EP.Semantix.Token.NotNounPhrase">
            <summary>
            Это используется внутренним образом 
            (признак того, что здесь не начинается именная группа, чтобы повторно не пытаться выделять)
            </summary>
        </member>
        <member name="P:EP.Semantix.Token.WhitespacesBeforeCount">
            <summary>
            Количество пробелов перед, переход на новую строку = 10, табуляция = 5
            </summary>
        </member>
        <member name="P:EP.Semantix.Token.NewlinesBeforeCount">
            <summary>
            Количество переходов на новую строку перед
            </summary>
        </member>
        <member name="P:EP.Semantix.Token.NewlinesAfterCount">
            <summary>
            Количество переходов на новую строку перед
            </summary>
        </member>
        <member name="P:EP.Semantix.Token.WhitespacesAfterCount">
            <summary>
            Количество пробелов перед, переход на новую строку = 10, табуляция = 5
            </summary>
        </member>
        <member name="P:EP.Semantix.Token.IsHiphen">
            <summary>
            Это символ переноса
            </summary>
        </member>
        <member name="P:EP.Semantix.Token.IsTableControlChar">
            <summary>
            Это спец-символы для табличных элементов (7h, 1Eh, 1Fh)
            </summary>
        </member>
        <member name="P:EP.Semantix.Token.IsAnd">
            <summary>
            Это соединительный союз И (на всех языках)
            </summary>
        </member>
        <member name="P:EP.Semantix.Token.IsOr">
            <summary>
            Это соединительный союз ИЛИ (на всех языках)
            </summary>
        </member>
        <member name="P:EP.Semantix.Token.IsComma">
            <summary>
            Это запятая
            </summary>
        </member>
        <member name="P:EP.Semantix.Token.IsCommaAnd">
            <summary>
            Это запятая или союз И
            </summary>
        </member>
        <member name="P:EP.Semantix.Token.IsLetters">
            <summary>
            Признак того, что это буквенный текстовой токен (TextToken)
            </summary>
        </member>
        <member name="P:EP.Semantix.Token.IsNumber">
            <summary>
            Это число (в различных вариантах задания)
            </summary>
        </member>
        <member name="P:EP.Semantix.Token.IsReferent">
            <summary>
            Это сущность (Referent)
            </summary>
        </member>
        <member name="P:EP.Semantix.MetaToken.BeginToken">
            <summary>
            Начальный токен диапазона
            </summary>
        </member>
        <member name="P:EP.Semantix.MetaToken.EndToken">
            <summary>
            Конечный токен диапазона
            </summary>
        </member>
        <member name="P:EP.Semantix.MetaToken.TokensCount">
            <summary>
            Количество токенов в диапазоне
            </summary>
        </member>
        <member name="P:EP.Semantix.Internal.NounPhraseItem.CanBeNumericAdj">
            <summary>
            Это признак количественного (число, НЕСКОЛЬКО, МНОГО)
            </summary>
        </member>
        <member name="P:EP.Semantix.Internal.NounPhraseItem.IsVerb">
            <summary>
            Это признак причастия
            </summary>
        </member>
        <member name="T:EP.Semantix.Internal.NounPhraseItemTextVar">
            <summary>
            Морфологический вариант для элемента именной группы
            </summary>
        </member>
        <member name="F:EP.Semantix.Internal.NounPhraseItemTextVar.NormalValue">
            <summary>
            Нормализованное значение
            </summary>
        </member>
        <member name="F:EP.Semantix.Internal.NounPhraseItemTextVar.SingleNumberValue">
            <summary>
            Нормализованное значение в единственном числе
            </summary>
        </member>
        <member name="T:EP.Semantix.Termin">
            <summary>
            Термин, понятие, система обозначений чего-либо и варианты его написания
            </summary>
        </member>
        <member name="F:EP.Semantix.Termin.Terms">
            <summary>
            Морфологические токены полного написания
            </summary>
        </member>
        <member name="F:EP.Semantix.Termin.AdditionalVars">
            <summary>
            Дополнительные варианты
            </summary>
        </member>
        <member name="M:EP.Semantix.Termin.AddVariant(System.String,System.Boolean)">
            <summary>
            Добавить дополнительный вариант полного написания
            </summary>
            <param name="var"></param>
        </member>
        <member name="F:EP.Semantix.Termin.IgnoreTermsOrder">
            <summary>
            Порядок токенов неважен (то есть привязка с точностью до перестановок)
            </summary>
        </member>
        <member name="F:EP.Semantix.Termin.Acronym">
            <summary>
            Возможная аббревиатура (всегда слитно в верхнем регистре)
            </summary>
        </member>
        <member name="F:EP.Semantix.Termin.AcronymSmart">
            <summary>
            "Мягкая" аббревиатура, допускающая разбивку, точки и т.п.
            </summary>
        </member>
        <member name="F:EP.Semantix.Termin.AcronymCanBeLower">
            <summary>
            Аббревиатура м.б. в нижнем регистре
            </summary>
        </member>
        <member name="M:EP.Semantix.Termin.SetStdAcronim(System.Boolean)">
            <summary>
            Установить стандартную аббревиатуру
            </summary>
        </member>
        <member name="F:EP.Semantix.Termin.Abridges">
            <summary>
            Список возможных сокращений
            </summary>
        </member>
        <member name="F:EP.Semantix.Termin.Lang">
            <summary>
            Язык
            </summary>
        </member>
        <member name="F:EP.Semantix.Termin.Tag">
            <summary>
            Используется произвольным образом
            </summary>
        </member>
        <member name="F:EP.Semantix.Termin.Tag2">
            <summary>
            Используется произвольным образом
            </summary>
        </member>
        <member name="M:EP.Semantix.Termin.AddAllAbridges(System.Int32,System.Int32,System.Int32)">
            <summary>
            Добавить все сокращения (с первой буквы до любого согласного)
            </summary>
        </member>
        <member name="M:EP.Semantix.Termin.TryParse(EP.Semantix.Token,EP.Semantix.TerminParseAttr)">
            <summary>
            Попробовать привязать термин
            </summary>
            <param name="t0"></param>
            <param name="fullWordsOnly"></param>
            <returns></returns>
        </member>
        <member name="P:EP.Semantix.Termin.CanonicText">
            <summary>
            Каноноический текст
            </summary>
        </member>
        <member name="P:EP.Semantix.Termin.Gender">
            <summary>
            Род (первого термина)
            </summary>
        </member>
        <member name="T:EP.Semantix.Termin.Term">
            <summary>
            Элемент термина (слово или число)
            </summary>
        </member>
        <member name="F:EP.Semantix.Termin.Term.IsPatternAny">
            <summary>
            То есть на месте этого терма может быть всё, что угодно
            </summary>
        </member>
        <member name="M:EP.Semantix.Termin.Term.Check(EP.Semantix.Token)">
            <summary>
            Сравнение с токеном
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="P:EP.Semantix.Termin.Term.Variants">
            <summary>
            Варианты морфологического написания
            </summary>
        </member>
        <member name="P:EP.Semantix.Termin.Term.CanonicalText">
            <summary>
            Каноническое изображение (первый вариант)
            </summary>
        </member>
        <member name="P:EP.Semantix.Termin.Term.IsNumber">
            <summary>
            Признак того, что это число
            </summary>
        </member>
        <member name="P:EP.Semantix.Termin.Term.IsHiphen">
            <summary>
            Это перенос
            </summary>
        </member>
        <member name="P:EP.Semantix.Termin.Term.IsPoint">
            <summary>
            Это точка
            </summary>
        </member>
        <member name="P:EP.Semantix.Termin.Term.Gender">
            <summary>
            Род
            </summary>
        </member>
        <member name="T:EP.Semantix.TableHelper">
            <summary>
            Поддержка работы с таблицами, расположенными в текстах.
            Начало таблицы - символ 1Eh, конец - 1Fh, ячейки оканчиваются 07h,
            комбинация 0D 0A 07 - конец строки.
            Данную структуру формирует функция извлечения текстов (ExtractText), так что это - для
            обратного восстановления таблицы в случае необходимости.
            </summary>
        </member>
        <member name="M:EP.Semantix.TableHelper.TryParseRows(EP.Semantix.Token,System.Int32,System.Boolean)">
            <summary>
            Получить список строк таблицы
            </summary>
            <param name="t">начальная позиция</param>
            <param name="maxChar">максимальная позиция (0 - не ограничена)</param>
            <param name="mustBeStartOfTable">при true первый символ должен быть 1Eh</param>
            <returns>список строк</returns>
        </member>
        <member name="T:EP.Semantix.TableRowToken">
            <summary>
            Токен - строка таблицы из текста
            </summary>
        </member>
        <member name="F:EP.Semantix.TableRowToken.Cells">
            <summary>
            Ячейки строки таблицы
            </summary>
        </member>
        <member name="T:EP.Semantix.TableCellToken">
            <summary>
            Токен - ячейка таблицы
            </summary>
        </member>
        <member name="F:EP.Semantix.TableCellToken.ColSpan">
            <summary>
            Количество объединённых ячеек по горизонтали
            </summary>
        </member>
        <member name="F:EP.Semantix.TableCellToken.RowSpan">
            <summary>
            Количество объединённых ячеек по вертикали
            </summary>
        </member>
        <member name="T:EP.Semantix.NumberToken">
            <summary>
            Числовой токен (числительное)
            </summary>
        </member>
        <member name="F:EP.Semantix.NumberToken.Value">
            <summary>
            Числовое значение
            </summary>
        </member>
        <member name="F:EP.Semantix.NumberToken.Typ">
            <summary>
            Тип написания
            </summary>
        </member>
        <member name="T:EP.Semantix.NumberToken.SpellingType">
            <summary>
            Возможные типы написаний
            </summary>
        </member>
        <member name="F:EP.Semantix.NumberToken.SpellingType.Digit">
            <summary>
            Цифрами
            </summary>
        </member>
        <member name="F:EP.Semantix.NumberToken.SpellingType.Roman">
            <summary>
            Римскими цифрами
            </summary>
        </member>
        <member name="F:EP.Semantix.NumberToken.SpellingType.Words">
            <summary>
            Прописью (словами)
            </summary>
        </member>
        <member name="F:EP.Semantix.NumberToken.SpellingType.Age">
            <summary>
            Возраст (летие)
            </summary>
        </member>
        <member name="T:EP.Semantix.StatisticCollection">
            <summary>
            Поддержка анализа биграммной зависимости токенов в тексте
            </summary>
        </member>
        <member name="F:EP.Semantix.StatisticCollection.WordInfo.HasBeforePersonAttr">
            <summary>
            Есть ли перед атрибут персон (вычисляется только в процессе отработки соотв. анализатора на его 1-м проходе) 
            </summary>
        </member>
        <member name="F:EP.Semantix.StatisticCollection.WordInfo.NotCapitalBeforeCount">
            <summary>
            Количество слов перед этим, которые не тексты или в нижнем регистре
            (например, для проверки отчеств - фамилия ли это)
            </summary>
        </member>
        <member name="T:EP.Semantix.AnalyzerData">
            <summary>
            Данные, полученные в ходе обработки анализатором
            </summary>
        </member>
        <member name="F:EP.Semantix.AnalyzerData.Kit">
            <summary>
            Ссылка на аналитический контейнер
            </summary>
        </member>
        <member name="M:EP.Semantix.AnalyzerData.RegisterReferent(EP.Referent)">
            <summary>
            Зарегистрировать новую сущность или привязать к существующей сущности
            </summary>
            <param name="referent"></param>
            <returns></returns>
        </member>
        <member name="P:EP.Semantix.AnalyzerData.Referents">
            <summary>
            Список выделенных сущностей
            </summary>
        </member>
        <member name="T:EP.Semantix.AnalyzerDataWithOntology">
            <summary>
            Данные, полученные в ходе обработки, причём с поддержкой механизма онтологий
            </summary>
        </member>
        <member name="T:EP.Semantix.MorphCollection">
            <summary>
            Коллекция морфологических вариантов
            </summary>
        </member>
        <member name="M:EP.Semantix.MorphCollection.Clone">
            <summary>
            Создать копию
            </summary>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.MorphCollection.RemoveItems(EP.Text.MorphCase)">
            <summary>
            Удалить элементы, не соответствующие падежу
            </summary>
            <param name="cas"></param>
        </member>
        <member name="M:EP.Semantix.MorphCollection.RemoveItems(EP.Text.MorphClass,System.Boolean)">
            <summary>
            Удалить элементы, не соответствующие классу
            </summary>
            <param name="cl"></param>
        </member>
        <member name="M:EP.Semantix.MorphCollection.RemoveItems(EP.Text.MorphBaseInfo)">
            <summary>
            Удалить элементы, не соответствующие параметрам
            </summary>
            <param name="inf"></param>
        </member>
        <member name="M:EP.Semantix.MorphCollection.RemoveItemsByPreposition(EP.Semantix.Token)">
            <summary>
            Убрать элементы, не соответствующие по падежу предлогу
            </summary>
            <param name="prep"></param>
        </member>
        <member name="M:EP.Semantix.MorphCollection.RemoveNotInDictionaryItems">
            <summary>
            Удалить элементы не из словаря
            </summary>
        </member>
        <member name="M:EP.Semantix.MorphCollection.RemoveItems(EP.Semantix.MorphCollection,EP.Text.MorphClass)">
            <summary>
            Удалить элементы, не соответствующие другой морфологической коллекции
            </summary>
            <param name="col"></param>
        </member>
        <member name="P:EP.Semantix.MorphCollection.ItemsCount">
            <summary>
            Количество морфологических вариантов
            </summary>
        </member>
        <member name="P:EP.Semantix.MorphCollection.Item(System.Int32)">
            <summary>
            Пролучить морфологический вариант
            </summary>
            <param name="ind"></param>
            <returns></returns>
        </member>
        <member name="P:EP.Semantix.MorphCollection.Items">
            <summary>
            Морфологические варианты
            </summary>
        </member>
        <member name="P:EP.Semantix.MorphCollection.Voice">
            <summary>
            Залог (для глаголов)
            </summary>
        </member>
        <member name="T:EP.Semantix.IntOntologyCollection">
            <summary>
            Онтологический словарь 
            </summary>
        </member>
        <member name="F:EP.Semantix.IntOntologyCollection.IsExtOntology">
            <summary>
            Признак того, что это внешняя онтология
            </summary>
        </member>
        <member name="M:EP.Semantix.IntOntologyCollection.Add(EP.Semantix.IntOntologyItem)">
            <summary>
            Добавить элемент (внимание, после добавления нельзя менять термины у элемента)
            </summary>
            <param name="di"></param>
        </member>
        <member name="M:EP.Semantix.IntOntologyCollection.Add(EP.Referent)">
            <summary>
            Добавить в онтологию сущность
            </summary>
            <param name="referent"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.IntOntologyCollection.AddTermin(EP.Semantix.IntOntologyItem,EP.Semantix.Termin)">
            <summary>
            Добавить термин в существующий элемент
            </summary>
            <param name="di"></param>
            <param name="t"></param>
        </member>
        <member name="M:EP.Semantix.IntOntologyCollection.Add(EP.Semantix.Termin)">
            <summary>
            Добавить отдельный термин (после добавления нельзя изменять свойства термина)
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:EP.Semantix.IntOntologyCollection.TryAttach(EP.Semantix.Token,System.String,System.Boolean)">
            <summary>
            Привязать с указанной позиции
            </summary>
            <param name="t"></param>
            <param name="canBeGeoObject">при True внутри может быть географический объект (Министерство РФ по делам ...)</param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.IntOntologyCollection.TryAttach(EP.Semantix.IntOntologyItem)">
            <summary>
            Найти похожие онтологические объекты
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.IntOntologyCollection.TryAttach(EP.Referent,EP.Semantix.IntOntologyItem,System.Boolean)">
            <summary>
            Найти эквивалентные сущности через онтологические объекты
            </summary>
            <param name="item"></param>
            <param name="referent"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.IntOntologyCollection.Remove(EP.Referent)">
            <summary>
            Удалить всё, что связано с сущностью
            </summary>
            <param name="r"></param>
        </member>
        <member name="P:EP.Semantix.IntOntologyCollection.Items">
            <summary>
            Список элементов онтологии
            </summary>
        </member>
        <member name="T:EP.Semantix.IntOntologyItem">
            <summary>
            Элемент онтологического словаря
            </summary>
        </member>
        <member name="F:EP.Semantix.IntOntologyItem.Termins">
            <summary>
            Список терминов, ассоциированных со словарной записью
            </summary>
        </member>
        <member name="M:EP.Semantix.IntOntologyItem.SetShortestCanonicalText(System.Boolean)">
            <summary>
            В качестве канонического текста установить самый короткий среди терминов
            </summary>
            <param name="ignoreTerminsWithNotnullTags"></param>
        </member>
        <member name="F:EP.Semantix.IntOntologyItem.Typ">
            <summary>
            Необязательный тип элемента
            </summary>
        </member>
        <member name="F:EP.Semantix.IntOntologyItem.MiscAttr">
            <summary>
            Используется произвольным образом (для некоторого дополнительного признака)
            </summary>
        </member>
        <member name="F:EP.Semantix.IntOntologyItem.Owner">
            <summary>
            Ссылка на онтологию
            </summary>
        </member>
        <member name="F:EP.Semantix.IntOntologyItem.OntologyElement">
            <summary>
            Ссылка на элемент внешней онтологии
            </summary>
        </member>
        <member name="F:EP.Semantix.IntOntologyItem.Referent">
            <summary>
            Ссылка на сущность
            </summary>
        </member>
        <member name="F:EP.Semantix.IntOntologyItem.Tag">
            <summary>
            Используется произвольным образом
            </summary>
        </member>
        <member name="P:EP.Semantix.IntOntologyItem.CanonicText">
            <summary>
            Каноноический текст
            </summary>
        </member>
        <member name="T:EP.Semantix.IntOntologyToken">
            <summary>
            Это привязка элемента отнологии к тексту
            </summary>
        </member>
        <member name="F:EP.Semantix.IntOntologyToken.Item">
            <summary>
            Элемент словаря
            </summary>
        </member>
        <member name="F:EP.Semantix.IntOntologyToken.Termin">
            <summary>
            Или просто отдельный термин
            </summary>
        </member>
        <member name="T:EP.Semantix.AnalysisKit">
            <summary>
            Внутренний аналитический контейнер данных
            </summary>
        </member>
        <member name="F:EP.Semantix.AnalysisKit.CorrectedTokens">
            <summary>
            Токены, подправленные по корректировочному словарю (SourceOfAnalysis.CorrectionDict).
            Здесь Value - исходый токен
            </summary>
        </member>
        <member name="M:EP.Semantix.AnalysisKit.EmbedToken(EP.Semantix.MetaToken)">
            <summary>
            Встроить токен в основную цепочку токенов
            </summary>
            <param name="mt"></param>
        </member>
        <member name="M:EP.Semantix.AnalysisKit.DebedToken(EP.Semantix.Token)">
            <summary>
            Убрать метатокен из цепочки, восстановив исходное
            </summary>
            <param name="t"></param>
            <returns>первый токен удалённого метатокена</returns>
        </member>
        <member name="F:EP.Semantix.AnalysisKit.FirstToken">
            <summary>
            Это начало цепочки токенов
            </summary>
        </member>
        <member name="F:EP.Semantix.AnalysisKit.Ontology">
            <summary>
            Внешняя онтология
            </summary>
        </member>
        <member name="F:EP.Semantix.AnalysisKit.BaseLanguage">
            <summary>
            Базовый язык
            </summary>
        </member>
        <member name="M:EP.Semantix.AnalysisKit.GetTextCharacter(System.Int32)">
            <summary>
            Получить символ из исходного текста
            </summary>
            <param name="position">позиция</param>
            <returns>символ (0, если выход за границу)</returns>
        </member>
        <member name="M:EP.Semantix.AnalysisKit.GetAnalyzerData(EP.Analyzer)">
            <summary>
            Работа с локальными данными анализаторов
            </summary>
            <param name="analyzer"></param>
            <returns></returns>
        </member>
        <member name="F:EP.Semantix.AnalysisKit.MiscData">
            <summary>
            Используется анализаторами произвольным образом
            </summary>
        </member>
        <member name="M:EP.Semantix.AnalysisKit.ReplaceReferent(EP.Referent,EP.Referent)">
            <summary>
            Заменить везде где только возможно старую сущность на новую (используется при объединении сущностей)
            </summary>
            <param name="oldReferent"></param>
            <param name="newReferent"></param>
        </member>
        <member name="F:EP.Semantix.AnalysisKit.Processor">
            <summary>
            Это для объединения внешних оттологических элементов
            </summary>
        </member>
        <member name="P:EP.Semantix.AnalysisKit.Entities">
            <summary>
            Список сущностей, выделенных в ходе анализа
            </summary>
        </member>
        <member name="P:EP.Semantix.AnalysisKit.Sofa">
            <summary>
            Ссылка на исходный текст
            </summary>
        </member>
        <member name="T:EP.Semantix.TerminCollection">
            <summary>
            Коллекций некоторых обозначений, терминов
            </summary>
        </member>
        <member name="F:EP.Semantix.TerminCollection.Termins">
            <summary>
            Полный список понятий
            </summary>
        </member>
        <member name="M:EP.Semantix.TerminCollection.Reindex(EP.Semantix.Termin)">
            <summary>
            Переиндексировать термин (если после добавления у него что-либо поменялось)
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:EP.Semantix.TerminCollection.TryParse(EP.Semantix.Token,EP.Semantix.TerminParseAttr)">
            <summary>
            Попытка привязать к аналитическому контейнеру с указанной позиции
            </summary>
            <param name="token">начальная позиция</param>
            <param name="pars">параметры выделения</param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.TerminCollection.TryParseAll(EP.Semantix.Token,EP.Semantix.TerminParseAttr)">
            <summary>
            Попытка привязать все возможные варианты
            </summary>
            <param name="token"></param>
            <param name="pars">параметры выделения</param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.TerminCollection.TryAttach(EP.Semantix.Termin)">
            <summary>
            Поискать эквивалентные термины
            </summary>
            <param name="termin"></param>
            <returns></returns>
        </member>
        <member name="T:EP.Semantix.TerminParseAttr">
            <summary>
            Патаметры выделения термина словаря (TryParse)
            </summary>
        </member>
        <member name="F:EP.Semantix.TerminParseAttr.FullwordsOnly">
            <summary>
            не использовать сокращения
            </summary>
        </member>
        <member name="F:EP.Semantix.TerminParseAttr.InDictionaryOnly">
            <summary>
            Рассматривать только варианты из морфологичского словаря
            </summary>
        </member>
        <member name="F:EP.Semantix.TerminParseAttr.TermOnly">
            <summary>
            Игнорировать морфологические варианты, а брать только терм
            </summary>
        </member>
        <member name="F:EP.Semantix.TerminParseAttr.CanBeGeoObject">
            <summary>
            Может иметь географический объект в середине (Министерство РФ по делам ...)
            </summary>
        </member>
        <member name="F:EP.Semantix.TerminParseAttr.IgnoreBrackets">
            <summary>
            Игнорировать скобки внутри нескольких термов
            </summary>
        </member>
        <member name="F:EP.Semantix.TerminParseAttr.IgnoreStopWords">
            <summary>
            Игнорировать знаки препинания, числа, союзы и предлоги
            </summary>
        </member>
        <member name="T:EP.Semantix.TerminToken">
            <summary>
            Результат привязки термина
            </summary>
        </member>
        <member name="T:EP.Referent">
            <summary>
            Базовый класс для всех сущностей
            </summary>
        </member>
        <member name="M:EP.Referent.ToString(System.Boolean,EP.Text.MorphLang,System.Int32)">
            <summary>
            Специализированное строковое представление сущности
            </summary>
            <param name="shortVariant">Сокращённый вариант</param>
            <param name="lang">Язык</param>
            <returns></returns>
        </member>
        <member name="M:EP.Referent.ToSortString">
            <summary>
            По этой строке можно осуществлять сортировку среди объектов одного типа
            </summary>
            <returns></returns>
        </member>
        <member name="F:EP.Referent.OntologyItems">
            <summary>
            Привязка к элементам внешней онтологии, если таковые были заданы
            (в принципе, может соответствовать несколько элементов онтологии)
            </summary>
        </member>
        <member name="M:EP.Referent.AddSlot(System.String,System.Object,System.Boolean,System.Int32)">
            <summary>
            Добавить значение атрибута
            </summary>
            <param name="attrName">имя</param>
            <param name="attrValue">значение</param>
            <param name="clearOldValue">если true и слот существует, то значение перезапишется</param>
            <returns></returns>
        </member>
        <member name="M:EP.Referent.FindSlot(System.String,System.Object,System.Boolean)">
            <summary>
            Найти слот
            </summary>
            <param name="attrName"></param>
            <param name="val"></param>
            <param name="useCanBeEqualsForReferents"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Referent.GetValue(System.String)">
            <summary>
            Получить значение (если их несколько, то вернёт первое)
            </summary>
            <param name="attrName"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Referent.GetStringValue(System.String)">
            <summary>
            Получить строковое значение (если их несколько, то вернёт первое)
            </summary>
            <param name="attrName"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Referent.GetStringValues(System.String)">
            <summary>
            Получить все строовые значения заданного атрибута
            </summary>
            <param name="attrName"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Referent.GetIntValue(System.String,System.Int32)">
            <summary>
            Получить числовое значение (если их несколько, то вернёт первое)
            </summary>
            <param name="attrName"></param>
            <param name="defValue"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Referent.AddOccurence(EP.TextAnnotation)">
            <summary>
            Добавить аннотацию
            </summary>
            <param name="anno"></param>
        </member>
        <member name="M:EP.Referent.CheckOccurence(System.Int32,System.Int32)">
            <summary>
            Проверка, что ссылки на элемент имеются на заданном участке текста
            </summary>
            <param name="beginChar"></param>
            <param name="endChar"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Referent.CanBeEquals(EP.Referent,EP.Referent.EqualType)">
            <summary>
            Проверка возможной тождественности объектов
            </summary>
            <param name="obj">другой объект</param>
            <param name="typ">тип сравнения</param>
            <returns>результат</returns>
        </member>
        <member name="M:EP.Referent.MergeSlots(EP.Referent,System.Boolean)">
            <summary>
            Объединение значений атрибутов со значениями атрибутов другого объекта
            </summary>
            <param name="obj">Другой объект, считающийся эквивалентным</param>
        </member>
        <member name="M:EP.Referent.GetImageId">
            <summary>
            Получить идентификатор иконки (саму иконку можно получить через функцию
            GetImageById(imageId) статического класса ProcessorService
            </summary>
            <returns></returns>
        </member>
        <member name="M:EP.Referent.CanBeGeneralFor(EP.Referent)">
            <summary>
            Проверка, может ли текущий объект быть обобщением для другого объекта
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Referent.CreateOntologyItem">
            <summary>
            Создать элемент отнологии
            </summary>
            <returns></returns>
        </member>
        <member name="F:EP.Referent.IntOntologyItem">
            <summary>
            Используется внутренним образом (напрямую не устанавливать!)
            </summary>
        </member>
        <member name="M:EP.Referent.GetCompareStrings">
            <summary>
            Используется внутренним образом
            </summary>
            <returns></returns>
        </member>
        <member name="M:EP.Referent.Serialize">
            <summary>
            Сериализация в строку XML 
            (последующая десериализация делается через Processor.DeserializeReferent)
            </summary>
            <returns></returns>
        </member>
        <member name="M:EP.Referent.Serialize(System.Xml.XmlWriter,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Прямая сериализация в XML
            </summary>
            <param name="xml"></param>
        </member>
        <member name="F:EP.Referent.RepositoryItemId">
            <summary>
            Используется внутренним образом (при сохранении сущностей в репозитории)
            </summary>
        </member>
        <member name="P:EP.Referent.TypeName">
            <summary>
            Имя типа (= InstanceOf.Name)
            </summary>
        </member>
        <member name="P:EP.Referent.InstanceOf">
            <summary>
            Ссылка на описание из модели данных
            </summary>
        </member>
        <member name="P:EP.Referent.Slots">
            <summary>
            Значения атрибутов
            </summary>
        </member>
        <member name="P:EP.Referent.Occurrence">
            <summary>
            Привязка элемента к текстам (аннотации)
            </summary>
        </member>
        <member name="P:EP.Referent.Tag">
            <summary>
            Используется произвольным образом
            </summary>
        </member>
        <member name="P:EP.Referent.ParentReferent">
            <summary>
            Ссылка на родительский объект (для разных типов объектов здесь может быть свои объекты,
            например, для организаций - вышестоящая организация, для пункта закона - сам закон и т.д.)
            </summary>
        </member>
        <member name="P:EP.Referent.GeneralReferent">
            <summary>
            Ссылка на объект-обобщение
            </summary>
        </member>
        <member name="T:EP.Referent.EqualType">
            <summary>
            Типы сравнение объектов
            </summary>
        </member>
        <member name="F:EP.Referent.EqualType.WithinOneText">
            <summary>
            Объекты в рамках одного текста
            </summary>
        </member>
        <member name="F:EP.Referent.EqualType.DifferentTexts">
            <summary>
            Объекты из разных текстов
            </summary>
        </member>
        <member name="F:EP.Referent.EqualType.ForMerging">
            <summary>
            Проверка для потенциального объединения объектов
            </summary>
        </member>
        <member name="T:EP.AnalysisResult">
            <summary>
            Результат анализа
            </summary>
        </member>
        <member name="F:EP.AnalysisResult.FirstToken">
            <summary>
            Ссылка на первый токен текста, который был проанализирован последним
            </summary>
        </member>
        <member name="F:EP.AnalysisResult.Ontology">
            <summary>
            Используемая внешняя онтология
            </summary>
        </member>
        <member name="F:EP.AnalysisResult.BaseLanguage">
            <summary>
            Базовый язык
            </summary>
        </member>
        <member name="F:EP.AnalysisResult.IsTimeoutBreaked">
            <summary>
            Процесс был прерван по таймауту (если был задан)
            </summary>
        </member>
        <member name="P:EP.AnalysisResult.Sofas">
            <summary>
            Входные анализируемые тексты
            </summary>
        </member>
        <member name="P:EP.AnalysisResult.Entities">
            <summary>
            Выделенные сущности
            </summary>
        </member>
        <member name="P:EP.AnalysisResult.Log">
            <summary>
            Это некоторые информационные сообщения
            </summary>
        </member>
        <member name="T:EP.RepositoryItemSample">
            <summary>
            Элемент примера сущности в тексте
            </summary>
        </member>
        <member name="F:EP.RepositoryItemSample.HeadPeace">
            <summary>
             Фрагмент перед
            </summary>
        </member>
        <member name="F:EP.RepositoryItemSample.BodyPeace">
            <summary>
            Сам фрагмент
            </summary>
        </member>
        <member name="F:EP.RepositoryItemSample.TailPeace">
            <summary>
            Фрагмент после
            </summary>
        </member>
        <member name="F:EP.RepositoryItemSample.IsEssential">
            <summary>
            Признак того, что этот текстовой фрагмент был использован для "первого" выделения сущности,
            а не привязки к ранее выделенному.
            </summary>
        </member>
        <member name="M:EP.RepositoryItemSample.Deserialize(System.String)">
            <summary>
            Представить в виде списка классов 
            </summary>
            <param name="samples"></param>
            <returns></returns>
        </member>
        <member name="T:EP.RepositoryItem">
            <summary>
            Элемент репозитория сущностей -
            представление сущности для СУБД или какго другого внешнего хранилища
            (обёртка над Referent)
            </summary>
        </member>
        <member name="F:EP.RepositoryItem.Data">
            <summary>
            Это строка, представляющая сериализацию сущности
            </summary>
        </member>
        <member name="F:EP.RepositoryItem.Samples">
            <summary>
            Это строка, в которой сериализуются примеры встречаемости сущности в текстах
            (для десериализации используйте класс RepositoryItemSample
            </summary>
        </member>
        <member name="F:EP.RepositoryItem.Tag">
            <summary>
            Используется произвольным образом
            </summary>
        </member>
        <member name="F:EP.RepositoryItem.Repository">
            <summary>
            Ссылка на репозиторий
            </summary>
        </member>
        <member name="F:EP.RepositoryItem.Referent">
            <summary>
            Экземпляр сущности 
            </summary>
        </member>
        <member name="F:EP.RepositoryItem.IsChanged">
            <summary>
            Признак изменения
            </summary>
        </member>
        <member name="P:EP.RepositoryItem.Id">
            <summary>
            Уникальный идентификатор внутри репозитория
            </summary>
        </member>
        <member name="P:EP.RepositoryItem.Spelling">
            <summary>
            Это ToString() от сущности
            </summary>
        </member>
        <member name="P:EP.RepositoryItem.Typ">
            <summary>
            Это тип сущности (поле TypeName)
            </summary>
        </member>
        <member name="P:EP.RepositoryItem.GeneralId">
            <summary>
            Идентификатор сущности-обобщения ("общее-частное")
            </summary>
        </member>
        <member name="P:EP.RepositoryItem.ParentId">
            <summary>
            Идентификатор сущности-контейнера ("часть-целое")
            </summary>
        </member>
        <member name="P:EP.RepositoryItem.ImageId">
            <summary>
            Идентификатор иконки (саму иконку можно получить через 
            ProcessorService.GetImageById(imageId)
            </summary>
        </member>
        <member name="T:EP.Semantix.ProperNameHelper">
            <summary>
            Поддержка работы с собственными именами
            </summary>
        </member>
        <member name="M:EP.Semantix.ProperNameHelper.GetNameWithoutBrackets(EP.Semantix.Token,EP.Semantix.Token,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Получить строковое значение между токенами, при этом исключая кавычки и скобки
            </summary>
            <param name="begin">начальный токен</param>
            <param name="end">конечный токен</param>
            <param name="normalizeFirstNounGroup">нормализовывать ли первую именную группу (именит. падеж)</param>
            <param name="normalFirstGroupSingle">приводить ли к единственному числу первую именную группу</param>
            <param name="ignoreGeoReferent">игнорировать внутри географические сущности</param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.ProperNameHelper.GetName(EP.Semantix.Token,EP.Semantix.Token)">
            <summary>
            Получить строковое значение между токенами без нормализации первой группы, всё в верхнем регистре.
            </summary>
            <param name="begin"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="T:EP.Semantix.NumberExToken">
            <summary>
            Число с стандартный постфиксом (мерой длины, вес, деньги и т.п.)
            </summary>
        </member>
        <member name="F:EP.Semantix.NumberExToken.RealValue">
            <summary>
            Это если заданы дроби ...
            </summary>
        </member>
        <member name="F:EP.Semantix.NumberExToken.AltRealValue">
            <summary>
            Это возможно в скобках другое написание
            </summary>
        </member>
        <member name="F:EP.Semantix.NumberExToken.ExTyp">
            <summary>
            Тип постфикса
            </summary>
        </member>
        <member name="F:EP.Semantix.NumberExToken.ExTyp2">
            <summary>
            Это постфикс после деления, например гр./м3
            </summary>
        </member>
        <member name="F:EP.Semantix.NumberExToken.ExTypParam">
            <summary>
            Дополнительный параметр постфикса (для денег - 3-х значный код валюты)
            </summary>
        </member>
        <member name="F:EP.Semantix.NumberExToken.MultAfter">
            <summary>
            Это признак того, что "множитель" слипся с единицей измерения
            </summary>
        </member>
        <member name="M:EP.Semantix.NumberExToken.TryParseFloatNumber(EP.Semantix.Token)">
            <summary>
            Это разделитель дроби по-умолчанию, используется для случаев, когда невозможно принять однозначного решения.
            Устанавливается на основе последнего успешного анализа.
            </summary>
        </member>
        <member name="M:EP.Semantix.NumberExToken.TryParseNumberWithPostfix(EP.Semantix.Token)">
            <summary>
            Выделение стандартных мер, типа: 10 кв.м.
            </summary>
        </member>
        <member name="M:EP.Semantix.NumberExToken.TryAttachPostfixOnly(EP.Semantix.Token)">
            <summary>
            Это попробовать только тип (постфикс) без самого числа
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:EP.Semantix.BracketSequenceToken">
            <summary>
            Представление последовательности, обрамлённой кавычками (скобками)
            </summary>
        </member>
        <member name="F:EP.Semantix.BracketSequenceToken.Internal">
            <summary>
            Внутренние подпоследовательности.
            Например, "О внесении изменений (2010-2011)", содержит внутри (2010-2011)
            </summary>
        </member>
        <member name="P:EP.Semantix.BracketSequenceToken.IsQuoteType">
            <summary>
            Признак обрамления кавычками (если false, то м.б. [...], (...), {...})
            </summary>
        </member>
        <member name="P:EP.Semantix.BracketSequenceToken.OpenChar">
            <summary>
            Открывающий символ
            </summary>
        </member>
        <member name="P:EP.Semantix.BracketSequenceToken.CloseChar">
            <summary>
            Закрывающий символ
            </summary>
        </member>
        <member name="T:EP.Slot">
            <summary>
            Значение атрибута в конкретном экземпляре сущности
            </summary>
        </member>
        <member name="F:EP.Slot.Count">
            <summary>
            Статистика встречаемости в объектах
            (например, используется для имён организаций, чтобы статистически определить
            правильное написание имени)
            </summary>
        </member>
        <member name="M:EP.Slot.Delete">
            <summary>
            Удалить слот из сущности
            </summary>
        </member>
        <member name="P:EP.Slot.DefiningFeature">
            <summary>
            Ссылка на атрибут метамодели
            </summary>
        </member>
        <member name="P:EP.Slot.Tag">
            <summary>
            Используется произвольным образом
            </summary>
        </member>
        <member name="T:EP.ReferentClass">
            <summary>
            Описатель некоторого класса сущностей
            </summary>
        </member>
        <member name="M:EP.ReferentClass.AddFeature(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Добавить фичу
            </summary>
            <param name="attrName"></param>
            <param name="attrCaption"></param>
            <param name="lowBound"></param>
            <param name="upBound"></param>
            <returns></returns>
        </member>
        <member name="M:EP.ReferentClass.FindFeature(System.String)">
            <summary>
            Найти атрибут по его системному имени
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:EP.ReferentClass.GetImageId(EP.Referent)">
            <summary>
            Вычислить картинку
            </summary>
            <param name="obj">если null, то общая картинка для типа</param>
            <returns>идентификатор картинки, саму картинку можно будет получить через ProcessorService.GetImageById</returns>
        </member>
        <member name="F:EP.ReferentClass.HideInGraph">
            <summary>
            Не выводить на графе объектов
            </summary>
        </member>
        <member name="P:EP.ReferentClass.Name">
            <summary>
            Строковый идентификатор
            </summary>
        </member>
        <member name="P:EP.ReferentClass.Caption">
            <summary>
            Заголовок (зависит от текущего языка)
            </summary>
        </member>
        <member name="P:EP.ReferentClass.Features">
            <summary>
            Атрибуты класса
            </summary>
        </member>
        <member name="T:EP.Feature">
            <summary>
            Атрибут класса сущностей
            </summary>
        </member>
        <member name="P:EP.Feature.Name">
            <summary>
            Внутреннее имя
            </summary>
        </member>
        <member name="P:EP.Feature.Caption">
            <summary>
            Заголовок
            </summary>
        </member>
        <member name="P:EP.Feature.LowerBound">
            <summary>
            Минимальное количество
            </summary>
        </member>
        <member name="P:EP.Feature.UpperBound">
            <summary>
            Максимальное количество (0 - неограничено)
            </summary>
        </member>
        <member name="P:EP.Feature.ShowAsParent">
            <summary>
            Это для внутреннего использования
            </summary>
        </member>
        <member name="T:EP.RepositoryBase">
            <summary>
            Репозиторий сущностей (базовый класс)
            </summary>
        </member>
        <member name="M:EP.RepositoryBase.ResetFetchItems">
            <summary>
            Инициализировать извлечение всех элементов
            </summary>
        </member>
        <member name="M:EP.RepositoryBase.FetchNextItem">
            <summary>
            Извлечь очередной элемент
            </summary>
            <returns></returns>
        </member>
        <member name="M:EP.RepositoryBase.GetItem(System.Int32)">
            <summary>
            Получить элемент по его идентификатору
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:EP.RepositoryBase.SaveItem(EP.RepositoryItem)">
            <summary>
            Сохранить изменения. Если у элемента нулевой идентификатор, то это новый
            элемент, и новое значение нужно записать в поле Id.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:EP.RepositoryBase.MergeItems(EP.RepositoryItem,System.Collections.Generic.List{EP.RepositoryItem})">
            <summary>
            Объединить сущности. Необходимо сохранить baseItem, удалить mergedItems,
            а также предпринять усилия по обеспечению целостности информации, если
            кто-либо извне ссылается на удаляемые элементы.
            </summary>
            <param name="baseItem"></param>
            <param name="mergedItems"></param>
        </member>
        <member name="M:EP.RepositoryBase.AddAdditionalData(EP.RepositoryItem,System.Object)">
            <summary>
            Добавить в элемент дополнительную информацию (которая поступает из RepositoryInputItem.AdditionalData)
            </summary>
            <param name="item"></param>
            <param name="additionalData"></param>
        </member>
        <member name="M:EP.RepositoryBase.CreateItem">
            <summary>
            Создать экземпляр элемента (по умолчанию создаётся RepositoryItem)
            </summary>
            <returns></returns>
        </member>
        <member name="M:EP.RepositoryBase.Initialize">
            <summary>
            Инициализация репозитория (необходимо вызывать перед первым использованием) 
            </summary>
        </member>
        <member name="M:EP.RepositoryBase.Deinitialize">
            <summary>
            Вызывать в конце работы
            </summary>
        </member>
        <member name="M:EP.RepositoryBase.GetOutgoingItems(System.Int32)">
            <summary>
            Получить список всех элементов, на которые ссылается указанный
            </summary>
            <param name="itemId"></param>
            <returns></returns>
        </member>
        <member name="M:EP.RepositoryBase.GetIncomingItems(System.Int32)">
            <summary>
            Получить список всех элементов, которые ссылаются на указанный элемент
            </summary>
            <param name="itemId"></param>
            <returns></returns>
        </member>
        <member name="M:EP.RepositoryBase.SaveReferents(System.Collections.Generic.ICollection{EP.RepositoryInputItem})">
            <summary>
            Сохранить сущности
            </summary>
            <param name="input">список обёрток над сущностями</param>
        </member>
        <member name="M:EP.RepositoryBase.FindItems(EP.Referent,System.Boolean)">
            <summary>
            Найти для сущности существующие в хранилище элементы
            </summary>
            <param name="referent"></param>
            <param name="includeGenerals">при true будет включать в список сущности с учётом отношения обобщения</param>
            <returns>список (null - если нет аналогов)</returns>
        </member>
        <member name="M:EP.RepositoryBase._mergeEntities(System.Collections.Generic.List{EP.Referent},System.Int32,System.Boolean)">
            <summary>
            Объединение сущностей - тонкая вещь
            </summary>
            <param name="res"></param>
        </member>
        <member name="P:EP.RepositoryBase.Processor">
            <summary>
            Экземпляр процессора, используемого при десериализации
            (по умолчанию, создаётся с полным набором доступных анализаторов)
            </summary>
        </member>
        <member name="P:EP.RepositoryBase.SaveTextSamples">
            <summary>
            Сохранять ли примеры фрагментов текстов
            </summary>
        </member>
        <member name="P:EP.RepositoryBase.ItemsCount">
            <summary>
            Общее число элементов в репозитории
            </summary>
        </member>
        <member name="P:EP.RepositoryBase.AllItems">
            <summary>
            Перечисление всех элеменов
            </summary>
        </member>
        <member name="E:EP.RepositoryBase.MessageOccured">
            <summary>
            Это для сообщений
            </summary>
        </member>
        <member name="M:EP.Semantix.RusLatAccord.GetVariants(System.String)">
            <summary>
            Сформировать всевозможные варианты написаний на другой раскладке
            </summary>
            <param name="rusOrLat">слово на кириллице или латинице</param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.RusLatAccord.FindAccordsRusToLat(System.String,System.Int32,System.Collections.Generic.List{System.String})">
            <summary>
            Вернёт длину привязки
            </summary>
            <param name="txt"></param>
            <param name="pos"></param>
            <param name="res"></param>
            <returns></returns>
        </member>
        <member name="T:EP.Semantix.TextToken">
            <summary>
            Входной токен (после морфанализа)
            </summary>
        </member>
        <member name="F:EP.Semantix.TextToken.Source">
            <summary>
            Ссылка на исходный разбор (результат морфологии)
            </summary>
        </member>
        <member name="F:EP.Semantix.TextToken.Term">
            <summary>
            Исходный фрагмент, слегка нормализованный (не морфологически, а символьно)
            </summary>
        </member>
        <member name="M:EP.Semantix.TextToken.GetLemma">
            <summary>
            Получить нормализованное слово (лемма)
            </summary>
            <returns></returns>
        </member>
        <member name="F:EP.Semantix.TextToken.InvariantPrefixLength">
            <summary>
            Это количество начальных символов, одинаковых для всех морфологических вариантов
            (пригодится для оптимизации поиска)
            </summary>
        </member>
        <member name="F:EP.Semantix.TextToken.MaxLength">
            <summary>
            Максимальная длина среди морфвариантов
            </summary>
        </member>
        <member name="M:EP.Semantix.TextToken.CheckValue(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Попробовать привязать словарь
            </summary>
            <param name="dict"></param>
            <returns></returns>
        </member>
        <member name="P:EP.Semantix.TextToken.IsPureVerb">
            <summary>
            Признак того, что это чистый глагол
            </summary>
        </member>
        <member name="T:EP.Semantix.ReferentToken">
            <summary>
            Токен, соответствующий сущности
            </summary>
        </member>
        <member name="F:EP.Semantix.ReferentToken.Referent">
            <summary>
            Ссылка на сущность
            </summary>
        </member>
        <member name="F:EP.Semantix.ReferentToken.MiscAttrs">
            <summary>
            Используется произвольным образом
            </summary>
        </member>
        <member name="T:EP.RepositoryInputItem">
            <summary>
            Это обёртка для входной сущности
            </summary>
        </member>
        <member name="F:EP.RepositoryInputItem.Referent">
            <summary>
            Это должно быть установлено на входе
            </summary>
        </member>
        <member name="F:EP.RepositoryInputItem.Samples">
            <summary>
            Здесь могут быть ранее подготовленные примеры вхождений
            (если нет, то будут вычисляться из Referent.Occurence)
            </summary>
        </member>
        <member name="F:EP.RepositoryInputItem.AdditionalData">
            <summary>
            Некоторые дополнительные данные
            </summary>
        </member>
        <member name="F:EP.RepositoryInputItem.Tag">
            <summary>
            Используется произвольным образом
            </summary>
        </member>
        <member name="F:EP.RepositoryInputItem.Item">
            <summary>
            Это будет установлено после сохранения
            </summary>
        </member>
        <member name="F:EP.RepositoryInputItem.Tmp">
            <summary>
            Используется внутренним образом
            </summary>
        </member>
        <member name="T:EP.Analyzer">
            <summary>
            Базовый класс для всех семантических анализаторов (картриджей обработки данных)
            </summary>
        </member>
        <member name="M:EP.Analyzer.Process(EP.Semantix.AnalysisKit)">
            <summary>
            Запустить анализ
            </summary>
            <param name="kit"></param>
            <param name="data"></param>
        </member>
        <member name="M:EP.Analyzer.CreateReferent(System.String)">
            <summary>
            Создать объект указанного типа
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Analyzer.CreateAnalyzerData">
            <summary>
            Используется внутренним образом
            </summary>
            <returns></returns>
        </member>
        <member name="M:EP.Analyzer.ProcessReferent(EP.Semantix.Token,EP.Semantix.Token)">
            <summary>
            Попытаться выделить сущность в указанном диапазоне (используется внутренним образом).
            Кстати, выделенная сущность не сохраняется в локальной онтологии.
            </summary>
            <param name="begin">начало диапазона</param>
            <param name="end">конец диапазона (если null, то до конца)</param>
            <returns>результат</returns>
        </member>
        <member name="M:EP.Analyzer.ProcessOntologyItem(EP.Semantix.Token)">
            <summary>
            Это используется внутренним образом для обработки внешних онтологий
            </summary>
            <param name="begin"></param>
            <returns></returns>
        </member>
        <member name="P:EP.Analyzer.Name">
            <summary>
            Уникальное наименование анализатора
            </summary>
        </member>
        <member name="P:EP.Analyzer.Caption">
            <summary>
            Заголовок анализатора
            </summary>
        </member>
        <member name="P:EP.Analyzer.Description">
            <summary>
            Описание анализатора
            </summary>
        </member>
        <member name="P:EP.Analyzer.TypeSystem">
            <summary>
            Список поддерживаемых типов объектов, которые выделяет анализатор
            </summary>
        </member>
        <member name="P:EP.Analyzer.Images">
            <summary>
            Список изображений объектов
            </summary>
        </member>
        <member name="P:EP.Analyzer.IsSpecific">
            <summary>
            Признак специфического картриджа (предназначенного для конкретной предметной области)
            </summary>
        </member>
        <member name="P:EP.Analyzer.UsedExternObjectTypes">
            <summary>
            Список имён типов объектов из других картриджей, которые желательно предварительно выделить (для управления приоритетом применения правил)
            </summary>
        </member>
        <member name="P:EP.Analyzer.ModulePath">
            <summary>
            Это путь к DLL, содержащий этот картридж
            </summary>
        </member>
        <member name="P:EP.Analyzer.Processor">
            <summary>
            Ссылка на процессор
            </summary>
        </member>
        <member name="P:EP.Analyzer.PersistReferentsRegim">
            <summary>
            Включить режим накопления выделяемых сущностей при обработке разных SourceOfText
            (то есть локальные сущности будут накапливаться)
            </summary>
        </member>
        <member name="P:EP.Analyzer.IgnoreThisAnalyzer">
            <summary>
            При установке в true будет игнорироваться при обработке (для отладки)
            </summary>
        </member>
        <member name="T:EP.Semantix.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:EP.Semantix.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:EP.Semantix.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:EP.Semantix.Properties.Resources.Money">
             <summary>
               Looks up a localized string similar to австралийский доллар;доллар;AUD;100 центов;цент
            азербайджанский манат;манат;AZN;100 гяпиков;гяпик
            албанский лек;лек;ALL;100 киндарок;киндарка
            алжирский динар;динар;DZD;100 сантимов;сантим
            ангольская кванза;кванза;AOA;100 сентимо;сантим
            антильский гульден;гульден;ANG;100 центов;цент
            аргентинское песо;песо;ARS;100 сентаво;сентаво
            армянский драм;драм;AMD;100 лума;лум
            афганский афгани;афгани;AFN;100 пулов;пул
            багамский доллар;доллар;BSD;100 центов;цент
            бангладешская така;така;BDT;100 пайсов;пайс
            бахр [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:EP.Semantix.Properties.Resources.MoneyEN">
             <summary>
               Looks up a localized string similar to Australian dollar;us dollar;AUD;100 cents;cent
            AZN;AZN;AZN;100 qapiks;gepik
            Albanian Lek;Lek;ALL;100 kindrek;qindarka
            Algerian Dinar;Dinar;DZD;100 centimes;santim
            Angolan Kwanzaa;Kwanzaa;AOA;100;centime
            Antillean Guilder;ang;ANG;100 cents;cent
            Argentine peso;peso;ARS;100 centavos;centavos
            AMD;AMD;AMD;100 Lum;Lum
            Afghan Afghani;Afghani;AFN;100 pools;pool
            Bahamian dollar;dollar;BSD;100 cents;cent
            Bangladeshi Taka;Taka;BDT;100 paise;PICES
            Bahraini Dinar;Dinar;DZD;1000 Fils;Fils
            the Belarusian ruble;rubles;EUR; [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:EP.Semantix.Properties.Resources.MoneyUA">
             <summary>
               Looks up a localized string similar to австралійський долар;долар;AUD;100 центів;цент 
            азербайджанський манат;манат;AZN;100 гяпіків;гяпик 
            албанський лек;лек;ALL;100 киндарок;киндарка 
            алжирський динар;динар;DZD;100 сантимів;сантим 
            ангольська кванза;кванза;AOA;100 сентимо;сантим 
            антільський гульден;гульден;ANG;100 центів;цент 
            аргентинське песо;песо;ARS;100 сентаво;сентаво 
            вірменський драм;драм;AMD;100 лума;лум 
            афганські афгані;афгані;AFN;100 пулів;пул 
            багамський долар;долар;BSD;100 центів;цент 
            бангладешська така;така;BDT;100 пай [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="T:EP.Semantix.IDllInitializer">
            <summary>
            Интерфейс инициализатора DLL
            </summary>
        </member>
        <member name="M:EP.Semantix.IDllInitializer.Initialize">
            <summary>
            Инициализировать
            </summary>
        </member>
        <member name="T:EP.Semantix.NounPhraseToken">
            <summary>
            Токен для представления именной группы
            </summary>
        </member>
        <member name="F:EP.Semantix.NounPhraseToken.Noun">
            <summary>
            Корень группы (существительное, местоимение или сущность)
            </summary>
        </member>
        <member name="F:EP.Semantix.NounPhraseToken.Adjectives">
            <summary>
            Прилагательные (и причастия, если задан ключ ParseVerbs)
            </summary>
        </member>
        <member name="F:EP.Semantix.NounPhraseToken.Adverbs">
            <summary>
            Наречия (если задан ключ ParseAdverbs при выделении)
            </summary>
        </member>
        <member name="F:EP.Semantix.NounPhraseToken.InternalNoun">
            <summary>
            Для случая "по современным на данный момент представлениям" -
            это будет "данный момент"
            </summary>
        </member>
        <member name="F:EP.Semantix.NounPhraseToken.Anafor">
            <summary>
            Токен с анафорической ссылкой-местоимением (если есть), например: старшего своего брата
            </summary>
        </member>
        <member name="F:EP.Semantix.NounPhraseToken.Preposition">
            <summary>
            Начальный предлог предлог (если задан ключ ParsePreposition)
            </summary>
        </member>
        <member name="T:EP.ProcessorService">
            <summary>
            Глобальная служба семантического процессора
            </summary>
        </member>
        <member name="F:EP.ProcessorService.m_IsInited">
            <summary>
            Событие инициализации процессора.
            Приложение должно в обработчике этого события зарегистрировать необходимые для анализа картриджи,
            настроить глобальный репозиторий и т.п.
            </summary>
        </member>
        <member name="M:EP.ProcessorService.Initialize">
            <summary>
            Инициализация сервиса (русский и английский язык, все DLL с анализаторами
            динамически подгружаются из базовой директории - там же, где и этот модуль).
            ВНИМАНИЕ! Этот способ не подходит для приложений ASP.NET - см. документацию,
            как необходимо инициализировать в этом случае.
            </summary>
        </member>
        <member name="M:EP.ProcessorService.Initialize(System.Boolean,EP.Text.MorphLang)">
            <summary>
            Инициализация
            </summary>
            <param name="loadDll">загружать ли анализаторы из DLL в базовой директории</param>
            <param name="lang">необходимые языки (по умолчанию, русский и английский)</param>
        </member>
        <member name="M:EP.ProcessorService.RegisterAnalyzerType(System.Type)">
            <summary>
            Регистрация класса  обработки данных
            Вызывается в обработчике события Init.
            </summary>
            <param name="analyzer"></param>
        </member>
        <member name="M:EP.ProcessorService.LoadAllCartridgesFromDlls">
            <summary>
            Загрузить все картриджи из всех DLL (EP.Semantix.*.dll) из рабочей директории.
            Вызывается по умолчанию, если явно пользователм не были установлены
            </summary>
        </member>
        <member name="M:EP.ProcessorService.Create(System.String)">
            <summary>
            Создать экземпляр объекта заданного типа
            </summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:EP.ProcessorService.GetImageById(System.String)">
            <summary>
            Получить иконку по идентификатору иконки
            </summary>
            <param name="imageId"></param>
            <returns></returns>
        </member>
        <member name="P:EP.ProcessorService.Version">
            <summary>
            Версия системы
            </summary>
        </member>
        <member name="P:EP.ProcessorService.DefaultProcessor">
            <summary>
            Экземпляр дефолтного процессора
            </summary>
        </member>
        <member name="P:EP.ProcessorService.AnalyzerTypes">
            <summary>
            Зарегистрированные на данный момент анализаторы
            </summary>
        </member>
        <member name="P:EP.ProcessorService.AnalyzerInstances">
            <summary>
            Экземпляры доступных анализаторов
            </summary>
        </member>
        <member name="P:EP.ProcessorService.VersionDate">
            <summary>
            Дата-время текущей версии
            </summary>
        </member>
        <member name="T:EP.ImageWrapper">
            <summary>
            Приходится работать через обёртку, так как некоторые реализации .NET не содержат System.Drawing
            (например, для Андроида)
            </summary>
        </member>
        <member name="F:EP.ImageWrapper.Id">
            <summary>
            Уникальный идентификатор
            </summary>
        </member>
        <member name="F:EP.ImageWrapper.Content">
            <summary>
            Байтовый поток иконки
            </summary>
        </member>
        <member name="F:EP.ImageWrapper.Image">
            <summary>
            А здесь Bitmap вы уж сами формируйте, если нужно
            </summary>
        </member>
        <member name="T:EP.Semantix.NounPhraseHelper">
            <summary>
            Выделение именных групп (существительсно с согласованными прилагательными (если они есть).
            </summary>
        </member>
        <member name="M:EP.Semantix.NounPhraseHelper.TryParse(EP.Semantix.Token,EP.Semantix.NounPhraseParseAttr,System.Int32)">
            <summary>
            Попробовать создать именную группу с указанного токена
            </summary>
            <param name="t">начальный токен</param>
            <param name="typ">параметры (можно битовую маску)</param>
            <param name="maxCharPos">максимальная позиция в тексте, до которой выделять, если 0, то без ограничений</param>
            <returns>именная группа или null</returns>
        </member>
        <member name="T:EP.Semantix.NounPhraseParseAttr">
            <summary>
            Параметры выделения
            </summary>
        </member>
        <member name="F:EP.Semantix.NounPhraseParseAttr.ParsePronouns">
            <summary>
            Выделять ли местоимения (моя страна)
            </summary>
        </member>
        <member name="F:EP.Semantix.NounPhraseParseAttr.ParsePreposition">
            <summary>
            Выделять ли в начале предлог
            </summary>
        </member>
        <member name="F:EP.Semantix.NounPhraseParseAttr.IgnoreAdjBest">
            <summary>
            Игнорировать прилагательные превосходной степени
            </summary>
        </member>
        <member name="F:EP.Semantix.NounPhraseParseAttr.IgnoreParticiples">
            <summary>
            Игнорировать причастия, брать только чистые прилагательные
            </summary>
        </member>
        <member name="F:EP.Semantix.NounPhraseParseAttr.ReferentCanBeNoun">
            <summary>
            Корнем может выступать выделенная сущность (необъятная Россия)
            </summary>
        </member>
        <member name="F:EP.Semantix.NounPhraseParseAttr.CanNotHasCommaAnd">
            <summary>
            Между прилагательными не должно быть запятых и союзов
            </summary>
        </member>
        <member name="F:EP.Semantix.NounPhraseParseAttr.AdjectiveCanBeLast">
            <summary>
            Прилагательное м.б. на последнем месте (член моржовый)
            </summary>
        </member>
        <member name="F:EP.Semantix.NounPhraseParseAttr.ParseAdverbs">
            <summary>
            Выделять наречия
            </summary>
        </member>
        <member name="F:EP.Semantix.NounPhraseParseAttr.ParseVerbs">
            <summary>
            Выделять причастия (это прилагательные и глаголы одновременно)
            </summary>
        </member>
        <member name="F:EP.Semantix.NounPhraseParseAttr.ParseNumericAsAdjective">
            <summary>
            Выделять ли такие констркуции "двое сотрудников", "пять компаний" числа как прилагательные.
            Это не касается ситуаций "второй сотрудник", "пятая компания" - это всегда как прилагательные
            </summary>
        </member>
        <member name="F:EP.Semantix.NounPhraseParseAttr.Multilines">
            <summary>
            Группа может быть на разбита на нескольких строках (начало на одной, окончание на другой)
            </summary>
        </member>
        <member name="T:EP.Semantix.MiscHelper">
            <summary>
            Разные полезные процедурки
            </summary>
        </member>
        <member name="M:EP.Semantix.MiscHelper.IsNotMoreThanOneError(System.String,EP.Semantix.Token)">
            <summary>
            Сравнение, чтобы не было больше одной ошибки в написании.
            Ошибка - это замена буквы или пропуск буквы.
            </summary>
            <param name="value">правильное написание</param>
            <param name="t">проверяемый токен</param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.MiscHelper.TryAttachWordByLetters(System.String,EP.Semantix.Token,System.Boolean)">
            <summary>
            Проверить написание слова вразбивку по буквам (например:   П Р И К А З)
            </summary>
            <param name="word">проверяемое слово</param>
            <param name="t">начальный токен</param>
            <param name="useMorphVariants">перебирать ли падежи у слова</param>
            <returns>токен последней буквы или null</returns>
        </member>
        <member name="M:EP.Semantix.MiscHelper.CanBeEquals(System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Сравнение 2-х строк на предмет равенства с учётом морфологии и пунктуации (то есть инвариантно относительно них).
            Функция довольно трудоёмка, не использовать без крайней необходимости.
            </summary>
            <param name="s1"></param>
            <param name="s2"></param>
            <param name="ignoreNonletters"></param>
            <param name="ignoreCase"></param>
            <param name="checkMorphEquAfterFirstNoun">После первого существительного слова должны полностью совпадать</param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.MiscHelper.CanBeStartOfSentence(EP.Semantix.Token)">
            <summary>
            Проверка того, может ли здесь начинаться новое предложение
            </summary>
            <param name="t">токен начала предложения</param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.MiscHelper.FindEndOfSentence(EP.Semantix.Token)">
            <summary>
            Переместиться на конец предложения
            </summary>
            <param name="t">токен, с которого идёт поиск</param>
            <returns>последний токен предложения (не обязательно точка!)</returns>
        </member>
        <member name="M:EP.Semantix.MiscHelper.CheckNumberPrefix(EP.Semantix.Token)">
            <summary>
            Привязка различных способов написания ключевых слов для номеров (ном., №, рег.номер и пр.)
            </summary>
            <param name="t">начало префикса</param>
            <returns>null, если не префикс, или токен, следующий сразу за префиксом номера</returns>
        </member>
        <member name="M:EP.Semantix.MiscHelper.ConvertFirstCharUpperAndOtherLower(System.String)">
            <summary>
            Преобразовать строку чтобы первая буква стала большой, остальные маленькие
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.MiscHelper.ConvertLatinWordToRussianVariants(System.String)">
            <summary>
            Преобразовать слово, написанное по латыни, в варианты на русском языке.
            Например, "Mikhail" -> "Михаил"
            </summary>
            <param name="str">Строка на латыни</param>
            <returns>Варианты на русском языке</returns>
        </member>
        <member name="M:EP.Semantix.MiscHelper.ConvertRussianWordToLatinVariants(System.String)">
            <summary>
            Преобразовать слово, написанное в кириллице, в варианты на латинице.
            </summary>
            <param name="str">Строка на кириллице</param>
            <returns>Варианты на латинице</returns>
        </member>
        <member name="M:EP.Semantix.MiscHelper.GetAbsoluteNormalValue(System.String,System.Boolean)">
            <summary>
            Получение абсолютного нормализованного значения (с учётом гласных, удалением невидимых знаков и т.п.).
            Используется для сравнений различных вариантов написаний.
            Преобразования:  гласные заменяются на *, Щ на Ш, Х на Г, одинаковые соседние буквы сливаются,
            Ъ и Ь выбрасываются.
            Например, ХАБИБУЛЛИН -  Г*Б*Б*Л*Н
            </summary>
            <param name="str">страка</param>
            <returns>если null, то не удалось нормализовать (слишком короткий)</returns>
        </member>
        <member name="M:EP.Semantix.MiscHelper.IsExistsInDictionary(EP.Semantix.Token,EP.Semantix.Token,EP.Text.MorphClass)">
            <summary>
            Проверка, что хотя бы одно из слов внутри заданного диапазона находится в морфологическом словаре
            </summary>
            <param name="begin"></param>
            <param name="end"></param>
            <param name="cla"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.MiscHelper.IsAllCharactersLower(EP.Semantix.Token,EP.Semantix.Token,System.Boolean)">
            <summary>
            Проверка, что все в заданном диапазоне в нижнем регистре
            </summary>
            <param name="begin"></param>
            <param name="end"></param>
            <param name="errorIfNotText"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.MiscHelper.HasVowel(EP.Semantix.TextToken)">
            <summary>
            Текстовой токен должен иметь гласную
            </summary>
            <param name="t">токен</param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.MiscHelper.TestAcronym(EP.Semantix.Token,EP.Semantix.Token,EP.Semantix.Token)">
            <summary>
            Проверка акронима, что из первых букв слов диапазона может получиться проверяемый акроним.
            Например,  РФ = Российская Федерация, ГосПлан = государственный план
            </summary>
            <param name="acr">акроним</param>
            <param name="begin">начало диапазона</param>
            <param name="end">конец диапазона</param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.MiscHelper.GetCyrLatWord(EP.Semantix.Token,System.Int32)">
            <summary>
            Получить вариант на кириллице и\или латинице
            </summary>
            <param name="t"></param>
            <param name="maxLen"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.MiscHelper.CanBeEqualCyrAndLat(EP.Semantix.Token,System.String)">
            <summary>
            Проверка на возможную эквивалентность русского и латинского написания одного и того же слова
            </summary>
            <param name="t"></param>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.MiscHelper.CanBeEqualCyrAndLat(EP.Semantix.Token,EP.Semantix.Token)">
            <summary>
            Проверка на возможную эквивалентность русского и латинского написания одного и того же слова.
            Например,  ИКЕЯ ? IKEA
            </summary>
            <param name="t1">токен на одном языке</param>
            <param name="t2">токен на другом языке</param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.MiscHelper.CanBeEqualCyrAndLat(System.String,System.String)">
            <summary>
            Проверка на возможную эквивалентность русского и латинского написания одного и того же слова.
            Например,  ИКЕЯ ? IKEA
            </summary>
            <param name="str1">слово на одном языке</param>
            <param name="str2">слово на другом языке</param>
            <returns></returns>
        </member>
        <member name="M:EP.Semantix.MiscHelper.GetTextValue(EP.Semantix.MetaToken,EP.Semantix.GetTextAttr)">
            <summary>
            Получить текст, покрываемый метатокеном
            </summary>
            <param name="mt">метатокен</param>
            <param name="attrs">атрибуты преобразования текста</param>
            <returns>результат</returns>
        </member>
        <member name="M:EP.Semantix.MiscHelper.GetTextValue(EP.Semantix.Token,EP.Semantix.Token,EP.Semantix.GetTextAttr)">
            <summary>
            Получить текст, задаваемый диапазоном токенов
            </summary>
            <param name="begin">начальный токен</param>
            <param name="end">конечный токен</param>
            <param name="attrs">атрибуты преобразования текста</param>
            <returns>результат</returns>
        </member>
        <member name="M:EP.Semantix.MiscHelper.IsEngAdjSuffix(EP.Semantix.Token)">
            <summary>
            Проверка, что это суффикс прилагательного (street's)
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:EP.Semantix.GetTextAttr">
            <summary>
            Атрибуты получения текста
            </summary>
        </member>
        <member name="F:EP.Semantix.GetTextAttr.KeepRegister">
            <summary>
            Сохранять ли регистр букв (по умолчанию, верхний регистр)
            </summary>
        </member>
        <member name="F:EP.Semantix.GetTextAttr.FirstNounGroupToNominative">
            <summary>
            Первую именную группу преобразовывать к именительному падежу
            </summary>
        </member>
        <member name="F:EP.Semantix.GetTextAttr.FirstNounGroupToNominativeSingle">
            <summary>
            Первую именную группу преобразовывать к именительному падежу единственному числу
            </summary>
        </member>
        <member name="F:EP.Semantix.GetTextAttr.KeepQuotes">
            <summary>
            Оставлять кавычки (по умолчанию, кавычки игнорируются). К скобкам это не относится.
            </summary>
        </member>
        <member name="F:EP.Semantix.GetTextAttr.IgnoreGeoReferent">
            <summary>
            Игнорировать географические объекты
            </summary>
        </member>
        <member name="F:EP.Semantix.GetTextAttr.NormalizeNumbers">
            <summary>
            Преобразовать ли числовые значения в цифры
            </summary>
        </member>
        <member name="F:EP.Semantix.GetTextAttr.RestoreRegister">
            <summary>
            Если все слова в верхнем регистре, то попытаться восстановить слова в нижнем регистре
            на основе их встречаемости в других частях всего документа
            (то есть если слово есть в нижнем, то оно переводится в нижний)
            </summary>
        </member>
        <member name="F:EP.Semantix.GetTextAttr.IgnoreArticles">
            <summary>
            Для английского языка игнорировать артикли и суффикс 'S 
            </summary>
        </member>
        <member name="T:EP.ExtOntology">
            <summary>
            Внешняя онтология
            </summary>
        </member>
        <member name="M:EP.ExtOntology.Add(System.Object,System.String,System.String)">
            <summary>
            Добавить элемент
            </summary>
            <param name="extId">произвольный объект</param>
            <param name="typeName">имя типа сущности</param>
            <param name="definition">текстовое определение. Определение может содержать несколько 
            отдельных фрагментов, которые разделяются точкой с запятой.
            Например, Министерство Обороны России; Минобороны</param>
            <returns>если null, то не получилось...</returns>
        </member>
        <member name="M:EP.ExtOntology.Add(System.Object,EP.Referent)">
            <summary>
            Добавить элемент
            </summary>
            <param name="extId">произвольный объект</param>
            <param name="referent">готовая сущность (например, сфомированная явно)</param>
            <returns></returns>
        </member>
        <member name="M:EP.ExtOntology.Refresh(EP.ExtOntologyItem,System.String)">
            <summary>
            Обновить существующий элемент онтологии
            </summary>
            <param name="item"></param>
            <param name="definition">новое определение</param>
            <returns></returns>
        </member>
        <member name="M:EP.ExtOntology.Refresh(EP.ExtOntologyItem,EP.Referent)">
            <summary>
            Обновить существующий элемент онтологии
            </summary>
            <param name="item"></param>
            <param name="newReferent"></param>
            <returns></returns>
        </member>
        <member name="F:EP.ExtOntology.Items">
            <summary>
            Список элементов внешней онтологии
            </summary>
        </member>
        <member name="M:EP.ExtOntology._getAnalyzerData(System.String)">
            <summary>
            Используется внутренним образом
            </summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:EP.ExtOntology.AttachToken(System.String,EP.Semantix.Token)">
            <summary>
            Используется внутренним образом
            </summary>
            <param name="typeName"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:EP.ExtOntologyItem">
            <summary>
            Элемент внешней онтологии
            </summary>
        </member>
        <member name="F:EP.ExtOntologyItem.ExtId">
            <summary>
            Внешний идентификатор (ссылка на что угодно)
            </summary>
        </member>
        <member name="F:EP.ExtOntologyItem.TypeName">
            <summary>
            Имя типа
            </summary>
        </member>
        <member name="F:EP.ExtOntologyItem.Referent">
            <summary>
            Ссылка на сущность
            </summary>
        </member>
    </members>
</doc>
